// Code generated by mfd-generator v0.6.0; DO NOT EDIT.

//nolint:all
//lint:file-ignore U1000 ignore unused code, it's generated
package db

import (
	"time"

	"github.com/go-pg/pg/v10"
	"github.com/go-pg/pg/v10/orm"
)

const condition = "?.? = ?"

// base filters
type applier func(query *orm.Query) (*orm.Query, error)

type search struct {
	appliers []applier
}

func (s *search) apply(query *orm.Query) {
	for _, applier := range s.appliers {
		query.Apply(applier)
	}
}

func (s *search) where(query *orm.Query, table, field string, value interface{}) {
	query.Where(condition, pg.Ident(table), pg.Ident(field), value)
}

func (s *search) WithApply(a applier) {
	if s.appliers == nil {
		s.appliers = []applier{}
	}
	s.appliers = append(s.appliers, a)
}

func (s *search) With(condition string, params ...interface{}) {
	s.WithApply(func(query *orm.Query) (*orm.Query, error) {
		return query.Where(condition, params...), nil
	})
}

// Searcher is interface for every generated filter
type Searcher interface {
	Apply(query *orm.Query) *orm.Query
	Q() applier

	With(condition string, params ...interface{})
	WithApply(a applier)
}

type UserSearch struct {
	search

	ID                    *int
	CreatedAt             *time.Time
	Login                 *string
	Password              *string
	AuthKey               *string
	LastActivityAt        *time.Time
	StatusID              *int
	TelegramID            *int64
	TelegramUsername      *string
	TeleramFirstName      *string
	TelegramLastName      *string
	IDs                   []int
	NotID                 *int
	LoginILike            *string
	PasswordILike         *string
	AuthKeyILike          *string
	LastActivityAtFrom    *time.Time
	LastActivityAtTo      *time.Time
	TelegramUsernameILike *string
	TeleramFirstNameILike *string
	TelegramLastNameILike *string
}

func (us *UserSearch) Apply(query *orm.Query) *orm.Query {
	if us == nil {
		return query
	}
	if us.ID != nil {
		us.where(query, Tables.User.Alias, Columns.User.ID, us.ID)
	}
	if us.CreatedAt != nil {
		us.where(query, Tables.User.Alias, Columns.User.CreatedAt, us.CreatedAt)
	}
	if us.Login != nil {
		us.where(query, Tables.User.Alias, Columns.User.Login, us.Login)
	}
	if us.Password != nil {
		us.where(query, Tables.User.Alias, Columns.User.Password, us.Password)
	}
	if us.AuthKey != nil {
		us.where(query, Tables.User.Alias, Columns.User.AuthKey, us.AuthKey)
	}
	if us.LastActivityAt != nil {
		us.where(query, Tables.User.Alias, Columns.User.LastActivityAt, us.LastActivityAt)
	}
	if us.StatusID != nil {
		us.where(query, Tables.User.Alias, Columns.User.StatusID, us.StatusID)
	}
	if us.TelegramID != nil {
		us.where(query, Tables.User.Alias, Columns.User.TelegramID, us.TelegramID)
	}
	if us.TelegramUsername != nil {
		us.where(query, Tables.User.Alias, Columns.User.TelegramUsername, us.TelegramUsername)
	}
	if us.TeleramFirstName != nil {
		us.where(query, Tables.User.Alias, Columns.User.TeleramFirstName, us.TeleramFirstName)
	}
	if us.TelegramLastName != nil {
		us.where(query, Tables.User.Alias, Columns.User.TelegramLastName, us.TelegramLastName)
	}
	if len(us.IDs) > 0 {
		Filter{Columns.User.ID, us.IDs, SearchTypeArray, false}.Apply(query)
	}
	if us.NotID != nil {
		Filter{Columns.User.ID, *us.NotID, SearchTypeEquals, true}.Apply(query)
	}
	if us.LoginILike != nil {
		Filter{Columns.User.Login, *us.LoginILike, SearchTypeILike, false}.Apply(query)
	}
	if us.PasswordILike != nil {
		Filter{Columns.User.Password, *us.PasswordILike, SearchTypeILike, false}.Apply(query)
	}
	if us.AuthKeyILike != nil {
		Filter{Columns.User.AuthKey, *us.AuthKeyILike, SearchTypeILike, false}.Apply(query)
	}
	if us.LastActivityAtFrom != nil {
		Filter{Columns.User.LastActivityAt, *us.LastActivityAtFrom, SearchTypeGE, false}.Apply(query)
	}
	if us.LastActivityAtTo != nil {
		Filter{Columns.User.LastActivityAt, *us.LastActivityAtTo, SearchTypeLE, false}.Apply(query)
	}
	if us.TelegramUsernameILike != nil {
		Filter{Columns.User.TelegramUsername, *us.TelegramUsernameILike, SearchTypeILike, false}.Apply(query)
	}
	if us.TeleramFirstNameILike != nil {
		Filter{Columns.User.TeleramFirstName, *us.TeleramFirstNameILike, SearchTypeILike, false}.Apply(query)
	}
	if us.TelegramLastNameILike != nil {
		Filter{Columns.User.TelegramLastName, *us.TelegramLastNameILike, SearchTypeILike, false}.Apply(query)
	}

	us.apply(query)

	return query
}

func (us *UserSearch) Q() applier {
	return func(query *orm.Query) (*orm.Query, error) {
		if us == nil {
			return query, nil
		}
		return us.Apply(query), nil
	}
}

type CategorySearch struct {
	search

	ID         *int
	UserID     *int
	Title      *string
	Alias      *string
	CreatedAt  *time.Time
	UpdatedAt  *time.Time
	StatusID   *int
	IDs        []int
	NotID      *int
	TitleILike *string
}

func (cs *CategorySearch) Apply(query *orm.Query) *orm.Query {
	if cs == nil {
		return query
	}
	if cs.ID != nil {
		cs.where(query, Tables.Category.Alias, Columns.Category.ID, cs.ID)
	}
	if cs.UserID != nil {
		cs.where(query, Tables.Category.Alias, Columns.Category.UserID, cs.UserID)
	}
	if cs.Title != nil {
		cs.where(query, Tables.Category.Alias, Columns.Category.Title, cs.Title)
	}
	if cs.Alias != nil {
		cs.where(query, Tables.Category.Alias, Columns.Category.Alias, cs.Alias)
	}
	if cs.CreatedAt != nil {
		cs.where(query, Tables.Category.Alias, Columns.Category.CreatedAt, cs.CreatedAt)
	}
	if cs.UpdatedAt != nil {
		cs.where(query, Tables.Category.Alias, Columns.Category.UpdatedAt, cs.UpdatedAt)
	}
	if cs.StatusID != nil {
		cs.where(query, Tables.Category.Alias, Columns.Category.StatusID, cs.StatusID)
	}
	if len(cs.IDs) > 0 {
		Filter{Columns.Category.ID, cs.IDs, SearchTypeArray, false}.Apply(query)
	}
	if cs.NotID != nil {
		Filter{Columns.Category.ID, *cs.NotID, SearchTypeEquals, true}.Apply(query)
	}
	if cs.TitleILike != nil {
		Filter{Columns.Category.Title, *cs.TitleILike, SearchTypeILike, false}.Apply(query)
	}

	cs.apply(query)

	return query
}

func (cs *CategorySearch) Q() applier {
	return func(query *orm.Query) (*orm.Query, error) {
		if cs == nil {
			return query, nil
		}
		return cs.Apply(query), nil
	}
}

type ExpenseSearch struct {
	search

	ID               *int
	UserID           *int
	CategoryID       *int
	Amount           *int
	Description      *string
	CreatedAt        *time.Time
	UpdatedAt        *time.Time
	StatusID         *int
	Currency         *string
	IDs              []int
	DescriptionILike *string
	CurrencyILike    *string
}

func (es *ExpenseSearch) Apply(query *orm.Query) *orm.Query {
	if es == nil {
		return query
	}
	if es.ID != nil {
		es.where(query, Tables.Expense.Alias, Columns.Expense.ID, es.ID)
	}
	if es.UserID != nil {
		es.where(query, Tables.Expense.Alias, Columns.Expense.UserID, es.UserID)
	}
	if es.CategoryID != nil {
		es.where(query, Tables.Expense.Alias, Columns.Expense.CategoryID, es.CategoryID)
	}
	if es.Amount != nil {
		es.where(query, Tables.Expense.Alias, Columns.Expense.Amount, es.Amount)
	}
	if es.Description != nil {
		es.where(query, Tables.Expense.Alias, Columns.Expense.Description, es.Description)
	}
	if es.CreatedAt != nil {
		es.where(query, Tables.Expense.Alias, Columns.Expense.CreatedAt, es.CreatedAt)
	}
	if es.UpdatedAt != nil {
		es.where(query, Tables.Expense.Alias, Columns.Expense.UpdatedAt, es.UpdatedAt)
	}
	if es.StatusID != nil {
		es.where(query, Tables.Expense.Alias, Columns.Expense.StatusID, es.StatusID)
	}
	if es.Currency != nil {
		es.where(query, Tables.Expense.Alias, Columns.Expense.Currency, es.Currency)
	}
	if len(es.IDs) > 0 {
		Filter{Columns.Expense.ID, es.IDs, SearchTypeArray, false}.Apply(query)
	}
	if es.DescriptionILike != nil {
		Filter{Columns.Expense.Description, *es.DescriptionILike, SearchTypeILike, false}.Apply(query)
	}
	if es.CurrencyILike != nil {
		Filter{Columns.Expense.Currency, *es.CurrencyILike, SearchTypeILike, false}.Apply(query)
	}

	es.apply(query)

	return query
}

func (es *ExpenseSearch) Q() applier {
	return func(query *orm.Query) (*orm.Query, error) {
		if es == nil {
			return query, nil
		}
		return es.Apply(query), nil
	}
}
